---
title: "Conversions Rabbit Hole"
output:
  html_document:
    df_print: paged
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(
  fig.width=12, 
  fig.height=8, 
  fig.path='Figs/',
  echo=FALSE,
  warning=FALSE,
  message=FALSE
  )
```

```{r setup}
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(gridExtra)
library(calibrate)
basedir = "../../tmp/results/rawdata/small/"
from_basedir = function(folder) {
  read_csv(paste(basedir, folder, sep=""))
}
results_summary <- from_basedir("conversion/results.callsite.summary.csv")
in_main = from_basedir("conversion/in-main/results.callsite.summary.csv")
in_test = from_basedir("conversion/in-test/results.callsite.summary.csv")
``` 

# Exploration of conversions

## Overall graph

The overall distribution of conversions, by location and by transitivity

```{r}
transform = function(df, where) {
  df %>%
    group_by(project, transitive) %>%
    summarise(count = sum(occurrences))
}

counts = rbind(transform(in_main, "main"), transform(in_test, "test"))

draw_transitivity_distribution = function(df, where) {
  ggplot(transform(df), aes(x = project, y = count, fill = transitive)) +
    geom_bar(stat = "identity", position = "dodge") +
    coord_flip() +
    theme(legend.position="bottom", legend.direction="horizontal",
                     legend.title = element_blank()) +
    labs(y = "# Conversions", x = "Project") +
    ggtitle(paste("Conversion transitivity distribution in", where)) +
    scale_fill_discrete(breaks=c("TRUE", "FALSE"),
                        labels=c("Transitive", "Non-transitive"))
}

draw_transitivity_distribution(in_main, "Main")
draw_transitivity_distribution(in_test, "Test")
```


## Helper functions

We define the filters that we found for call sites:

```{r}
known_testing_framework = function(name) {
  grepl("^utest", name) |
  grepl("^org.scalatest", name) |
  grepl("^org.specs2", name)
}

arrow_assoc = function(name) {
  name == "scala.Predef.ArrowAssoc"
}

other_scala_predefs = function(name) {
  (grepl("^scala.Predef", name) & !arrow_assoc(name))
}

low_prio_implicits = function(name) {
  grepl("scala.LowPriorityImplicits", name)
}

contains_quote = function(name) {
  grepl("[qQ]uote", name)
}

scala_option = function(name) {
  grepl("^scala.Option", name)
}

other_options = function(name) {
  !scala_option(name) &
  grepl("Option", name)
}

other_scala = function(name) {
  !arrow_assoc(name) &
  !other_scala_predefs(name) &
  !scala_option(name) &
  grepl("^scala.", name)
}

akka_actor = function(name) {
  grepl("^akka.actor.actorRef2Scala", name) |
  grepl("^akka.actor.scala2ActorRef", name)
}
```

And some helper traversal functions:

```{r}

filter_name = function(df, f) {
  df[f(df$name),]
}

filter_occurrences = function(df, f) {
  df[f(df$occurrences),]
}

sum_ocurrences = function(df) {
  sum(df$occurrences)
}

remainder = function(data, filters) {
   data[Reduce("&", Map({function(fun) !fun(data$name)}, filters)), ]
}

printgraph = function(data, names, title) {
  data = as.integer(data)
  pct <- round(data/sum(data)*100)
  #names = paste(names, ": ", sep="")
  #names = paste(names, data)
  names = paste(names, "(")
  names = paste(names, pct) # add percents to labels
  names = paste(names,"%)",sep="") # ad % to labels
  barplot(data, names.arg = names, horiz = TRUE, main=title, cex.names = 0.6, las = 2)
}
```

## All conversions per use

Modify the dataset to count conversions:

```{r}
all_conversions = results_summary %>%
  group_by(name) %>%
  summarise(occurrences = sum(occurrences)) %>%
  arrange(-occurrences)
```

Output the graph

```{r}
draw_conversion_distribution = function (df, title = "Distribution of transitive conversions by use ") {
  filters = c(known_testing_framework, arrow_assoc, other_scala_predefs, low_prio_implicits, contains_quote, scala_option, other_options, other_scala, akka_actor)
  total = sum_ocurrences(df)
  pietitle = paste(title, total)
  names = c("Unknown", "Testing libraries", "ArrowAssoc", "scala.Predef", "scala.LowPriorityImplicits", "Quotes", "Scala Options", "Other Options", "Other scala", "Akka actor <-> scala")

  distribution = Map({function(fun) sum_ocurrences(filter_name(df, fun))}, filters)

  with_totals = c(
    sum_ocurrences(remainder(df, filters)),
    distribution
  )

  printgraph(with_totals, names, pietitle)
}

draw_conversion_distribution(all_conversions, "Distribution of all conversions by use ")
```


## Exploration of transitive conversions

First we filter the dataset

```{r}
count_transitive_occurrences = function(df) {
  df[df$transitive,] %>%
    group_by(name) %>%
    summarise(occurrences = sum(occurrences)) %>%
    arrange(-occurrences)
}
transitive_conversions = count_transitive_occurrences(results_summary)
transitive_in_main = count_transitive_occurrences(in_main)
transitive_in_test = count_transitive_occurrences(in_test)
```


And finally, we can produce the graph

```{r}
draw_conversion_distribution(transitive_conversions)
draw_conversion_distribution(transitive_in_main, "Distribution of transitive conversions by use IN MAIN ")
draw_conversion_distribution(transitive_in_test, "Distribution of transitive conversions by use IN TEST ")
```

# Non-transitive conversions

Now let's plot the non-transitive conversion distribution. First, we filter out the transitive calls:

```{r}
nontransitive_conversions = results_summary[!results_summary$transitive,]
```

Then, we get the frequency counts, and we print it:

```{r}
summary = nontransitive_conversions %>%
  group_by(name) %>%
  summarise(occurrences = sum(occurrences)) %>%
  arrange(-occurrences)

freqCounts = nontransitive_conversions %>%
  group_by(occurrences) %>%
  summarise(count = n()) %>%
  arrange(occurrences, count)
plot(
  x = as.integer(freqCounts$count), 
  y = as.integer(freqCounts$occurrences), 
  log="yx", 
  xlab = "Number of implicits with that frequence",
  ylab= "Frequence: Number of conversions by this implicit", 
  main="Distribution of conversions by number of appearances"
)
```

This is not extremely useful, unfortunately.

We can envision another graph, with the same data but the axes changed:

```{r}
intervals = c(0, 1, 10, 100, 1000, 1000000)
partitioned = 
  split(summary, cut(summary$occurrences, intervals, include.lowest=TRUE))

palette = sample(heat.colors(length(intervals)))
barplot(
 sapply(partitioned,nrow),
 horiz = TRUE,
 las = 2,
 main = "Occurrence intervals of non-transitive implicit conversions",
 xlab = "Number of distinct conversion functions",
 ylab = "Number of occurrences"
)
```


Now, if we _don't_ mush the projects together, maybe we can gather some metadata. First, load the project stats.

```{r}
project_metadata <- from_basedir("project-metadata.csv")
```

Then, add LOC information to the nontransitive conversions:

```{r}
locDistribution = 
  left_join(nontransitive_conversions, project_metadata, by=c("project" = "reponame")) %>%
  mutate(name = name.x) %>%
  group_by(project) %>%
  summarise(
    occurrences = sum(occurrences), 
    scala_loc = min(scala_loc),
    call_density = occurrences / scala_loc)

relevantNames = function(df) {
 Map({function(row) {if (row.call_density < 0.1) {row.project = ""}}}, df)
}

plot(
  x = as.integer(locDistribution$scala_loc),
  y = as.integer(locDistribution$occurrences), 
  xlab = "Scala LOC", 
  ylab = "Non-transitive implicit conversions", 
  main="Distribution of non-transitive implicit conversions by scala LOC"
  )
```

## Types HOF

```{r}
draw_HOF = function (hof, where) {
  ggplot(hof, aes(name, occurrences)) +
    geom_bar(stat="identity") +
    coord_flip() +
    theme(legend.position="bottom", legend.direction="horizontal",
                     legend.title = element_blank()) +
    #labs(y = "# Conversions", x = "Project") +
    scale_y_discrete(limits = sort(unique(hof$occurrences))) +
    ggtitle(paste(where, "Hall of Fame"))
}

types_HOF = function(df, title) {
  count_by_name = function(df) {
    df %>% group_by(name) %>% summarise(occurrences = n()) %>% arrange(occurrences)
  }
  
  params_hof = df %>% mutate(name = param_type) %>% count_by_name
  returns_hof = df %>% mutate(name = return_type) %>% count_by_name
  
  require(gridExtra)
  grid.arrange(
    draw_HOF(returns_hof, "Return Type"),
    draw_HOF(params_hof, "Parameter Type"),
    ncol = 1
  )
} 
conversions = from_basedir("conversion/results.callsite.report.csv")
in_main = from_basedir("conversion/in-main/results.callsite.report.csv")
in_test = from_basedir("conversion/in-test/results.callsite.report.csv")
```

### Overall (Both test and main, both transitive and non-transitive)

```{r}
conversions = from_basedir("conversion/results.callsite.report.csv")
types_HOF(conversions, "Overall Conversion Type hall of fame")
```

### Transitive

#### In Main

```{r}
nont_conversions_in_main = in_main[in_main$transitive, ]
types_HOF(nont_conversions_in_main, "(NON-T in Main) Conversion Type hall of fame")
```

#### In Test

```{r}
nont_conversions_in_test = in_test[in_test$transitive, ]
types_HOF(nont_conversions_in_test, "(NON-T in Test) Conversion Type hall of fame")
```

### Non-Transitive

#### In Main

```{r}
nont_conversions_in_main = in_main[!in_main$transitive, ]
types_HOF(nont_conversions_in_main, "(NON-T in Main) Conversion Type hall of fame")
```

#### In Test

```{r}
nont_conversions_in_test = in_test[!in_test$transitive, ]
types_HOF(nont_conversions_in_test, "(NON-T in Test) Conversion Type hall of fame")
```


